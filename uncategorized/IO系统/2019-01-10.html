<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="IO系统[TOC] 目的：学习IO系统才能了解到内核驱动的管理方式，从而能够更加深入反钓鱼项目的一些可以优化的点。 CPU负责执行运算（大脑运算能力），并且通过内存总线操纵整个内存空间（大脑的记忆能力），这已经是一个计算机系统的雏形了。但作为个现实可用的计算机系统，仅仅具备这样的计算和内存访问能力还不够。  试想计算机没有键盘、鼠标、显示器的话；那么就没有人机交互了；没有硬盘的话，数据没办法持久化">
<meta property="og:type" content="article">
<meta property="og:title" content="Lnju&#39;s blogs">
<meta property="og:url" content="http://www.plaype.cc/uncategorized/IO系统/2019-01-10.html">
<meta property="og:site_name" content="Lnju&#39;s blogs">
<meta property="og:description" content="IO系统[TOC] 目的：学习IO系统才能了解到内核驱动的管理方式，从而能够更加深入反钓鱼项目的一些可以优化的点。 CPU负责执行运算（大脑运算能力），并且通过内存总线操纵整个内存空间（大脑的记忆能力），这已经是一个计算机系统的雏形了。但作为个现实可用的计算机系统，仅仅具备这样的计算和内存访问能力还不够。  试想计算机没有键盘、鼠标、显示器的话；那么就没有人机交互了；没有硬盘的话，数据没办法持久化">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.plaype.cc/uncategorized/images/Snipaste_2018-11-24_18-55-52.png">
<meta property="og:image" content="http://www.plaype.cc/uncategorized/Images/Snipaste_2018-11-24_19-26-44.png">
<meta property="og:image" content="http://www.plaype.cc/uncategorized/images/Snipaste_2018-12-02_16-48-42.png">
<meta property="og:image" content="http://www.plaype.cc/uncategorized/images/Snipaste_2018-12-02_17-27-40.png">
<meta property="og:image" content="http://www.plaype.cc/uncategorized/images/Snipaste_2018-12-03_22-47-45.png">
<meta property="og:updated_time" content="2018-12-03T18:30:39.948Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Lnju&#39;s blogs">
<meta name="twitter:description" content="IO系统[TOC] 目的：学习IO系统才能了解到内核驱动的管理方式，从而能够更加深入反钓鱼项目的一些可以优化的点。 CPU负责执行运算（大脑运算能力），并且通过内存总线操纵整个内存空间（大脑的记忆能力），这已经是一个计算机系统的雏形了。但作为个现实可用的计算机系统，仅仅具备这样的计算和内存访问能力还不够。  试想计算机没有键盘、鼠标、显示器的话；那么就没有人机交互了；没有硬盘的话，数据没办法持久化">
<meta name="twitter:image" content="http://www.plaype.cc/uncategorized/images/Snipaste_2018-11-24_18-55-52.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.plaype.cc/uncategorized/IO系统/2019-01-10.html">





  <title> | Lnju's blogs</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lnju's blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">曾梦想仗剑走天涯</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.plaype.cc/uncategorized/IO系统/2019-01-10.html">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lnju">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://www.plaype.me/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lnju's blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-10T23:49:29+08:00">
                2019-01-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="IO系统"><a href="#IO系统" class="headerlink" title="IO系统"></a>IO系统</h1><p>[TOC]</p>
<p>目的：学习IO系统才能了解到内核驱动的管理方式，从而能够更加深入反钓鱼项目的一些可以优化的点。</p>
<p>CPU负责执行运算（大脑运算能力），并且通过内存总线操纵整个内存空间（大脑的记忆能力），这已经是一个计算机系统的雏形了。但作为个现实可用的计算机系统，仅仅具备这样的计算和内存访问能力还不够。</p>
<blockquote>
<p>试想计算机没有键盘、鼠标、显示器的话；那么就没有人机交互了；没有硬盘的话，数据没办法持久化存储；没有网络适配器则没办法上网。</p>
<p>这就像人一样脑子再好用也是不够的，需要手脚、耳朵、喉咙与外部交互。</p>
</blockquote>
<p>鼠标、键盘、显示器、硬盘等等设备的功能和用途各式各样，那CPU怎么和他们打交道呢？标准的接口技术，和<strong>设备的控制器</strong>打交道。</p>
<p>从硬件层面上看，通过CPU的接口技术，计算机系统才能够在CPU的统一指挥下协作运行。</p>
<p>从软件层面上看，操作系统需提供相应的软件接口或系统服务给应用程序操作设备控制器，应用程序可以方便地操纵或使用外部设备。多线程、多进程的操作系统中这些外部设备对应用程序来说是共享的，所以系统必须统一协调对外部设备的访问。典型的做法是，应用程序不直接访问外部设备，而是通过操作系统来完成对设备的访问。Windows提供了一套可扩展的IO处理框架，从而允许硬件厂商编写系统模块来控制其硬件设备。这一套IO处理框架称为<strong>Windows I/O模型</strong>，它是对计算机<strong>外部设备工作原理的一个抽象</strong>，从而使得各种硬件设备都能够纳人到这一模型中。</p>
<p>在 Windows IO模型中，用于<strong>控制外部设备的软件模块称为设备驱动程序</strong>（Device Driver），它们运行在特权模式下，即内核模式下，所以它们的代码<strong>与内核代码具有同等的执行权限</strong>。因此，设备驱动程序<strong>必须遵循内核代码所必须遵守的一切规则</strong>，比如IRQL要求、内存管理规范等。另外，IO模型也是 Windows操作系统的软件扩展模型，这意味着，一个<strong>设备驱动程序可以与硬件设备毫无关联，而仅仅是扩展内核的功能</strong>，或者由于其他目的而需要在内核中执行代码 Windows的许多系统组件也正是以设备驱动程序的形式而提供的。<strong>因此，设备驱动程序并非真的要“驱动”一个硬件设备</strong>。</p>
<p>在这一章中大致内容：</p>
<ol>
<li>我们首先介绍现代计算机系统中IO的工作方式，并总体介绍 Windows内核中的IO系统结构。</li>
<li>分别讨论 Windows I/O系统的三大部件：IO管理器、即插即用管理器与电源管理器。</li>
<li>讨论 Windows的IO模型，介绍设备驱动程序的基本结构以及IO处理过程。</li>
</ol>
<h2 id="一、IO概述"><a href="#一、IO概述" class="headerlink" title="一、IO概述"></a>一、IO概述</h2><p>对于CPU来说，输入输出硬件设备其实只是符合某些接口规范的控制器而已，处理器并不直接与设备打交道，而是向设备控制器发号施令，或者接收设备控制器的通知或命令。</p>
<h3 id="1-1-现代计算机系统的I-O"><a href="#1-1-现代计算机系统的I-O" class="headerlink" title="1. 1 现代计算机系统的I/O"></a>1. 1 现代计算机系统的I/O</h3><p>按照传统分类，<strong>IO设备可以分为块设备和字符设备</strong>。像磁盘、光盘是典型的块设备，寻址和读写操作都是以块为单位进行的。另一类是字符设备，它们接收或发送的数据是字节流，而不是数据块。典型的字符设备有键盘和鼠标。</p>
<p><strong>处理器往往只跟设备的控制器打交道，而不直接操纵设备</strong>。处理器与控制器之间通过总线进行通信，而控制器与设备之间的通信则往往通过专门的接口进行，如图6.1所示。<strong>这些控制器的功能可能非常简单</strong>，比如像键盘控制器，它只处理键盘扫描码以及与系统进行简单的通信；<strong>有些控制器的功能可能非常复杂</strong>，比如现代的硬盘控制器，除了最基本的控制磁头读写数据的能力以外，还提供了校验数据的功能，以及不小的<strong>缓存空间</strong>。上一章中介绍的中断控制器也是一种控制器，其特殊之处在于，通过给处理器的一个管脚加上电信号，从而打断处理器当前的运行。许多设备利用中断控制器来通知处理器某些事情的发生，比如设备驱动程序请求的数据已经准备就绪。在上一章中我们已经看到了 Windows如何利用 ntel x86处理器的中断机制来实现统一的中断处理。</p>
<p><img src="..\images\Snipaste_2018-11-24_18-55-52.png" alt="Snipaste_2018-11-24_18-55-52"></p>
<p>设备控制器中往往有一些状态寄存器或者命令寄存器，因而<strong>处理器可以通过操纵这些寄存器，从而控制相应的设备</strong>，比如告诉控制器发送数据、接收数据、打开或关闭某些特定的功能。所以，操作系统的任务是根据设备的工作模式，读或写这些寄存器，从而达到控制外部设备的目的。<br>控制器中除了状态寄存器或者命令寄存器以外，可能还包含了<strong>可供处理器读写的数据缓冲区</strong>，例如块设备需要一个双方都可以访问的缓冲区用于传输数据；视频适配器往往有一段视频内存地址范围，允许处理器操纵显示器的屏幕输出结果。</p>
<p>我们来看一下 Intel x86处理器提供的设备接口功能。首先，Intel x86处理器除了内存地址空间以外，另外定义了一个IO端口（port）空间，<strong>指令in和out用于操纵端口空间中的数据单元</strong>。(<strong>方式1</strong>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out 21h，al</span><br></pre></td></tr></table></figure>
<p>0x21是8259A中断控制器的中断屏蔽寄存器（IMR，Interrupt Mask Register），该指令将CPU的AL寄存器中的值写到中断控制器的控制寄存器中，从而达到屏蔽某些中断信号的目的。</p>
<p>设备控制器中的寄存器除了通过IO端口来访问以外，也可以被映射到系统内存空间。<br>这种访问方案称为<strong>内存映射IO</strong>（memory-mapped I/O）（<strong>方式2</strong>）。例如，<strong>APIC中断控制器中的寄存器被映射</strong>到4KB大小的APIC寄存器地址空间，而APIC寄存器地址空间又被映射到系统内存中，映射的基址可以通过APIC基寄存器来设定。</p>
<p>一旦设定了内存映射IO的地址范围以后，当处理器寻址到此地址范围时，它实际上访问的就不再是原始内存空间中的存储单元，而是设备映射的数据单元。Intel x86处理器既支持IO端口地址空间，也支持内存映射IO。另一个典型的内存映射IO的例子是，视频缓冲区被映射到内存地址空间中，因而软件可以直接访问屏幕上显示的像素。</p>
<p>对于少量的数据交换，或者像VGA显示缓冲区这样固定地址范围的数据映射，使用上述做法是合适的。但是，对于像磁盘这样需要大量动态数据交换的设备，如果CPU使用IO寄存器逐个内存单元进行访问，或者通过固定地址范围的数据映射，则不仅<strong>存取效率不高，而且处理器操作也极为不便</strong>。对于这种情形，<strong>现代计算机通常采用一种直接内存访问（DMA，Direct Memory Access）的方案（方式3）</strong>。DMA需要硬件的支持，它也是一种控制器。既可以整个系统共享一个DMA控制器，也可以让一个设备，比如磁盘，有单独的DMA控制器，这取决于硬件的设计。<strong>DMA控制器通过系统总线来传输数据，但是它在传输数据时不占用处理器的指令周期</strong>，所以，<strong>使用DMA可以将处理器解放出来</strong>。<strong>当数据传输完成时，DMA控制器以中断的方式通知处理器</strong>。图6.2显示了通过DMA控制器来读写硬盘数据的硬件结构。</p>
<p><img src="..\Images\Snipaste_2018-11-24_19-26-44.png" alt="Snipaste_2018-11-24_19-26-44"></p>
<p>DMA通知硬盘控制器把数据从硬盘读出，放入到硬盘控制器的缓冲区中</p>
<blockquote>
<p>DMA控制器接到了处理器的读取硬盘数据的命令时，会首先告诉硬盘控制器，将要读取的数据先放到硬盘控制器的缓冲区中。从硬盘到硬盘控制器之间的数据传输是通过专用接口完成的，不需要使用系统总线，此通信完全不受硬件系统其他模块的影响。当数据到达硬盘控制器的缓冲区中，并且通过了校验和验证以后，DMA传输就可以进行了，接下来的数据传输需要用到系统总线。</p>
</blockquote>
<p>DMA控制器通过总线向硬盘控制器发出读请求，硬盘控制器把缓冲区数据通过系统总线传输到指定内存单元。</p>
<blockquote>
<p>当DMA控制器通过总线向硬盘控制器发出读请求时，磁盘控制器既不知道也不关心此请求来自处理器还是DMA控制器，由于要写的内存地址已经在总线的地址线上了，所以，磁盘控制器从内存缓冲区中取出当前要传输的字，将它送到总线上。这样就完成了个字的传输。DMA控制器用这种方法，将处理器指定要读取的所有字逐个地传输到内存中。然后向处理器请求中断。</p>
</blockquote>
<h3 id="1-2-I-O软件技术"><a href="#1-2-I-O软件技术" class="headerlink" title="1.2 I/O软件技术"></a>1.2 I/O软件技术</h3><p>I/O软件模型具备2个特点：</p>
<ul>
<li>通用性。即设备无关性，系统可以支持现有各种设备，甚至是未来才出现的设备</li>
<li>管理职责。能够让设备的软件组件融入到IO处理框架中（个人理解：类似于windows消息机制的callback比较适合实现），从而让设备的软件组件可以专注于针对特定某一款设备的功能需求（个人理解：解耦合）。例如：磁盘读写软件组件无须考虑磁盘上的文件系统。</li>
</ul>
<p>设备的软件组件通常称为<strong>设备驱动程序(device driver)</strong>，<strong>简称驱动程序</strong>。<br>设备驱动程序通常由设备的硬件厂商或操作系统厂商提供。<br>设备驱动程序工作在ring0，与系统内核代码权限相同。<br>设备驱动程序最最最基本的功能是，将操作系统的功能请求，解释成针对该设备的请求，然后操作设备以完成该请求，最后将结果返回给调用者。想要做好，这中间要考虑的问题有很多：</p>
<ul>
<li>与设备同步或异步通信</li>
<li>缓冲区管理</li>
<li>共享、独占设备。每个程序的磁盘IO请求是独立的，可以并存。但是一个程序必须以独占方式使用打印机。</li>
<li>设备状态管理</li>
</ul>
<p>设备驱动程序和操作系统的关系是<strong>依赖、互补</strong>的关系。设备驱动程序为操作系统提供了访问硬件设备的能力，但也依赖系统提供的同步互斥机制、内存管理机制、错误处理机制等等。对于多种设备通用功能，操作系统尽可能在同一的系统模块中实现。</p>
<p><img src="../images/Snipaste_2018-12-02_16-48-42.png" alt="Snipaste_2018-12-02_16-48-42"></p>
<h3 id="1-3-windows-IO系统结构"><a href="#1-3-windows-IO系统结构" class="headerlink" title="1.3 windows IO系统结构"></a>1.3 windows IO系统结构</h3><p>Windows的I/O系统由5部分组成：</p>
<ul>
<li>I/O管理器</li>
<li>即插即用管理器</li>
<li>电源管理器</li>
<li>WMI例程</li>
<li>设备驱动程序</li>
</ul>
<p>I/O管理器是整个I/O系统的核心，它定义了一个非常通用的框架，允许各种功能的设备驱动程序容纳于其中。WRK包含有I/O管理器的绝大部分代码，位于<code>base/ntos/io/iomgr</code></p>
<p>I/O管理器除了支持与设备相关的驱动程序以外，它也允许与设备无关的驱动程序加入到内核中。这一类驱动程序是内核扩展的一种形式。</p>
<p>Windows设备驱动程序可以直接访问硬件，或者通过硬件抽象层（HAL）访问硬件。但对于HAL未涵盖的硬件特性，设备驱动程序可以直接操纵设备控制器，以完成其功能。</p>
<p><strong>Windows I/O系统分层的驱动程序模型</strong></p>
<p>当I/O管理器接到一个I/O请求时，它可以将该请求传递给一个设备栈。位于栈顶的驱动程序首先处理I/O请求，然后依次将其向下传递，直到该I/O请求被完成。通常，与硬件关联的驱动程序位于设备栈的底端，它们直接驱动硬件设备来完成I/O任务。每个驱动程序只需关注自己的职责，而不必包揽I/O请求的完整处理过程。</p>
<p>Windows I/O系统非常依赖注册表，例如，设备与驱动程序的很多配置信息都保存在注册表中。</p>
<h2 id="二、I-O管理器"><a href="#二、I-O管理器" class="headerlink" title="二、I/O管理器"></a>二、I/O管理器</h2><p>I/O管理器是Windows I/O系统的核心组件，它负责建立起基本的I/O框架结构，允许各种类型的驱动程序纳入到这一框架结构中。I/O系统中，又有三种基本的内核对象：</p>
<ul>
<li>驱动程序对象：代表了一个设备驱动程序被加载到系统中以后的内部表示</li>
<li>设备对象：代表了系统中的一一个设备，它既可以是物理设备，也可以是逻辑设备</li>
<li>文件对象：代表了一个设备对象被打开后的实例。</li>
</ul>
<p>I/O管理器管理和协调这三种对象，并建立起它们之间的关系。这一节我们将讨论这些对象的创建和管理，首先讲述驱动程序的加载和初始化过程。</p>
<h3 id="2-1驱动程序初始化"><a href="#2-1驱动程序初始化" class="headerlink" title="2.1驱动程序初始化"></a>2.1驱动程序初始化</h3><p>I/O系统的初始化是在内核的阶段1初始化过程中完成的。阶段1初始化的主函数是<code>PhasellnitializationDiscard</code>，它调用<code>IoInitSystem</code>函数来初始化IO系统。</p>
<p>Windows中的每一个驱动程序（和Windows服务）在安装时都被指定了一个启动类型，存放在注册表HKLM\System\CurrentControlSet\Services\驱动名 的Start值中</p>
<p><img src="../images/Snipaste_2018-12-02_17-27-40.png" alt="Snipaste_2018-12-02_17-27-40"></p>
<p>启动类型是一个整数值，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Start Type</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVICE_BOOT_START             0x00000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVICE_SYSTEM_START           0x00000001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVICE_AUTO_START             0x00000002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVICE_DEMAND_START           0x00000003</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVICE_DISABLED               0x00000004</span></span><br></pre></td></tr></table></figure>
<p>下面看下枚举值0-4的启动类型的驱动程序的加载和初始化过程。</p>
<h4 id="SERVICE-BOOT-START-类型"><a href="#SERVICE-BOOT-START-类型" class="headerlink" title="SERVICE_BOOT_START 类型"></a><code>SERVICE_BOOT_START</code> 类型</h4><p>驱动程序是由系统加载器，即ntldr程序，加载到系统空间中的，因此，内核无须加载它们，直接初始化即可。初始化过程在<code>IopInitializeBootDrivers</code>完成，<code>IopInitializeBootDrivers</code>为每个驱动程序调用<code>IopInitializeBuiltinDriver</code>函数以完成实际的初始化工作。</p>
<p><code>IopInitializeBuiltinDriver</code>函数原型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">IopInitializeBuiltinDriver(</span><br><span class="line">    IN PUNICODE_STRING DriverName,						<span class="comment">//驱动程序名称</span></span><br><span class="line">    IN PUNICODE_STRING RegistryPath,					<span class="comment">//驱动程序对应注册表键路径</span></span><br><span class="line">    IN PDRIVER_INITIALIZE DriverInitializeRoutine,		 <span class="comment">//驱动程序初始化例程</span></span><br><span class="line">    IN PKLDR_DATA_TABLE_ENTRY DriverEntry,				<span class="comment">//指定驱动表项</span></span><br><span class="line">    IN BOOLEAN IsFilter,							   <span class="comment">//是否过滤驱动</span></span><br><span class="line">    IN PDRIVER_OBJECT *Result							<span class="comment">//若初始化成功返回驱动对象</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment">/*++</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Routine Description:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This routine is invoked to initialize a built-in driver.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Arguments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    DriverName - Specifies the name to be used in creating the driver object.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RegistryPath - Specifies the path to be used by the driver to get to</span></span><br><span class="line"><span class="comment">        the registry.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    DriverInitializeRoutine - Specifies the initialization entry point of</span></span><br><span class="line"><span class="comment">        the built-in driver.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    DriverEntry - Specifies the driver data table entry to determine if the</span></span><br><span class="line"><span class="comment">        driver is a wdm driver.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Return Value:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The function returns a pointer to a DRIVER_OBJECT if the built-in</span></span><br><span class="line"><span class="comment">    driver successfully initialized.  Otherwise, a value of NULL is returned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--*/</span></span><br></pre></td></tr></table></figure>
<p><code>IopInitializeBuiltinDriver</code>函数的基本流程：</p>
<ul>
<li>根据参数中指定的驱动程序名称，创建一个驱动程序对象</li>
<li>初始化该驱动程序对象，设置它的Driverlnit域为参数中指定的初始化例程</li>
<li>将驱动程序对象插入到System进程的句柄表中</li>
<li>搜索系统的已加载模块列表（全局变量PsLoadedModuleList），找到该驱动程序所在的模块项，并初始化驱动程序对象中与映像模块有关的域</li>
<li>将驱动程序的名称复制到驱动程序对象的名称缓冲区中，该缓冲区是从换页内存池中分配的</li>
<li>记录下驱动程序注册表键的名称</li>
<li>调用驱动程序的初始化函数(驱动入口函数DriverEntry)，即DriverlnitializeRoutine参数中指定的例程</li>
<li>调用lopReadyDeviceObjects函数，将该驱动程序创建的设备对象设置成已被初始化</li>
</ul>
<p><code>SERVICE_BOOT_START</code>驱动程序不是过滤驱动程序，所以<code>IsFilter</code>为<code>FALSE</code></p>
<h4 id="SERVICE-SYSTEM-START类型"><a href="#SERVICE-SYSTEM-START类型" class="headerlink" title="SERVICE_SYSTEM_START类型"></a><code>SERVICE_SYSTEM_START</code>类型</h4><p>驱动程序的初始化，这是在 <code>IopInitializeSystemDrivers</code> 函数中完成的，该函数通过<code>CmGetSystemDriverList</code>函数获得在注册表中“Start”值被指定为SERVICE_SYSTEM_START的驱动程序的列表，然后对尚未加载到系统中的驱动程序逐个调用<code>IopLoadDriver</code>函数，将其加载到系统地址空间，并执行初始化。<code>lopLoadDriver</code>函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">IopLoadDriver(</span><br><span class="line">    IN  HANDLE      KeyHandle,						<span class="comment">//驱动程序注册表键</span></span><br><span class="line">    IN  BOOLEAN     CheckForSafeBoot,				<span class="comment">//是否检查该驱动属于安全模式允许加载的驱动</span></span><br><span class="line">    IN  BOOLEAN     IsFilter,						<span class="comment">//是否过滤驱动</span></span><br><span class="line">    OUT NTSTATUS   *DriverEntryStatus				<span class="comment">//返回参数</span></span><br><span class="line">    )</span><br><span class="line"><span class="comment">/*++</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Routine Description:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This routine is invoked to load a device or file system driver, either</span></span><br><span class="line"><span class="comment">    during system initialization, or dynamically while the system is running.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Arguments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    KeyHandle - Supplies a handle to the driver service node in the registry</span></span><br><span class="line"><span class="comment">        that describes the driver to be loaded.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    IsFilter - TRUE if the driver is a WDM filter, FALSE otherwise.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    CheckForSafeBoot - If TRUE, the driver will be loaded only if it belongs</span></span><br><span class="line"><span class="comment">                       to the list of safe mode OK binaries.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    DriverEntryStatus - Receives status returned by DriverEntry(...)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Return Value:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The function value is the final status of the load operation. If</span></span><br><span class="line"><span class="comment">    STATUS_FAILED_DRIVER_ENTRY is returned, the driver's return value</span></span><br><span class="line"><span class="comment">    is stored in DriverEntryStatus.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Notes:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Note that this routine closes the KeyHandle before returning.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--*/</span></span><br></pre></td></tr></table></figure>
<p><code>lopLoadDriver</code> 是一个通用函数，它不仅用于引导时加载“系统-启动”类型的驱动程序，而且也被用于系统正常运行过程中动态地加载驱动程序。当<code>loplnitializeSystemDrivers</code> 调用该函数时，CheckForSafeBoot 参数为TRUE，而IsFilter 参数为FALSE。</p>
<p><code>lopLoadDriver</code> 函数的流程大体如下：</p>
<ul>
<li>根据参数中指定的注册表键，构造出驱动程序的全路径名</li>
<li>调用MmLoadSystemlmage函数，将驱动程序加载到系统地址空间</li>
<li>后面的步骤与<code>IoplnitializeBuiltinDriver</code>相仿：创建一个驱动程序对象，初始化该对象的域，尤其是，它的Driverlnit成员指向驱动程序的入口函数；然后将该对象插入到当前进程的句柄表中。完成了对象成员初始化以后，再调用驱动程序的初始化函数，即Driverlnit成员，并将驱动程序对象和注册表路径传递进去。</li>
</ul>
<h4 id="SERVICE-AUTO-START类型"><a href="#SERVICE-AUTO-START类型" class="headerlink" title="SERVICE_AUTO_START类型"></a>SERVICE_AUTO_START类型</h4><p><code>IopLoadDriver</code>和 <code>IoplnitializeBuiltinDriver</code> 函数都必须在System进程中运行，所以新创建的驱动程序对象将被加入到该进程的句柄表中。这对于“引导一启动”和“系统一启动”类型的驱动程序不成问题，因为它们的上游调用者<br>loplnitializeBootDrivers 和loplnitializeSystemDrivers 都是在lolnitSystem 函数中被调用的。然而，对于“自动-启动”类型的驱动程序，情形就不同了。“自动-启动”类型的驱动程序是在系统引导过程的后期，由SCM（services.exe进程）加载的。在内核中，这是通过<code>NtLoadDriver</code>函数来完成的。<code>NtLoadDriver</code> 是一个系统服务，其原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">NtLoadDriver (</span><br><span class="line">    __in PUNICODE_STRING DriverServiceName		<span class="comment">//加载的驱动在注册表中的名称</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment">/*++</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Routine Description:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    This service dynamically loads a device or file system driver into</span></span><br><span class="line"><span class="comment">    the currently running system.  It requires that the caller have the</span></span><br><span class="line"><span class="comment">    appropriate privilege to execute this service.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Arguments:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    DriverServiceName - Specifies the name of the node in the registry</span></span><br><span class="line"><span class="comment">        associated with the driver to be loaded.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Return Value:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The status returned is the final completion status of the load operation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--*/</span></span><br></pre></td></tr></table></figure>
<p>如果用户模式代码调用NtLoadDriver，那么，它需要检查当前进程是否有加载驱动程序的特权。然后，若当前进程是System进程，则直接调用lopLoadUnloadDriver函数完成驱动程序初始化工作；否则，将lopLoadUnloadDriver放到一个工作项目（Workltem）中，由System进程中的系统线程来调用lopLoadUnloadDriver函数。</p>
<p>看<code>IopLoadUnloadDriver</code>函数，该函数既可以用于加载驱动程序，也可以用于卸载驱动程序，取决于参数（LOAD_PACKET 数据结构）中指定的<code>DriverObject</code>是否已被赋了非零值。它直接调用<code>lopLoadDriver</code>函数来完成驱动程序的加载和初始化。</p>
<h4 id="SERVICE-DEMAND-START类型"><a href="#SERVICE-DEMAND-START类型" class="headerlink" title="SERVICE_DEMAND_START类型"></a><code>SERVICE_DEMAND_START</code>类型</h4><p>的驱动程序，这是在系统运行过程中，有些用户程序或者系统模块根据需要而加载的驱动程序，通过SCM来加载和初始化驱动程序。在这种情况下，驱动程序的加载经由<code>NtLoadDriver</code>系统服务来完成。此外，内核中的模块也可以根据需要加载并初始化“按需-启动”类型的驱动程序，譬如，在前面三类驱动程序的初始化过程中就存在这样的需求。在这种情况下，内核代码要么直接调用lopLoadDriver函数来完成驱动程序的加载，要么通过一个工作项目由系统辅助线程来完成加载工作。</p>
<p>小结：一旦一个驱动程序被加载并且初始化例程被执行，则该驱动程序就已经融入内核：它的代码已进入到系统地址空间，为内核模式下可执行代码的一部分；它已经获得了初始的执行权，以后如何再次获得执权，取决于初始例程中的代码逻辑。</p>
<h3 id="2-2-驱动程序对象和设备对象（review过）"><a href="#2-2-驱动程序对象和设备对象（review过）" class="headerlink" title="2.2 驱动程序对象和设备对象（review过）"></a>2.2 驱动程序对象和设备对象（review过）</h3><p>当I/O管理器加载一个设备驱动程序时，它会创建一个<strong>驱动程序对象</strong>。驱动程序可简单分为2类：</p>
<ul>
<li><strong>文件系统驱动程序</strong>，<strong>驱动程序对象</strong>在<strong>对象管理器目录</strong>中的路径为：<code>\FileSystem\DriverName</code></li>
<li><strong>非文件系统驱动程序</strong>，<strong>驱动程序对象</strong>在<strong>对象管理器目录</strong>中的路径为：<code>\Driver\DriverName</code></li>
</ul>
<p><strong>设备对象</strong>是与驱动程序相关的另一种对象，每个设备对象<strong>代表了系统中的一个设备</strong>（逻辑设备或物理设备）。我们需要知道，创建设备对象的途径有两种：</p>
<ul>
<li>即插即用管理器检测到设备时，通过调用驱动程序的<em>AddDevice</em>例程来创建设备对象</li>
<li>非即插即用驱动程序在它们的<em>初始化例程</em>中创建设备对象</li>
</ul>
<p><strong>关系</strong>：每个设备对象都必定有一个为它负责的驱动程序。<em>负责设备对象的驱动程序中的例程会操作设备对象</em>。</p>
<p><strong>数量关系</strong>：一个驱动程序可以支持多个设备，所以，<strong>驱动程序对象</strong>中有一个链表<strong>记录了它所负责的所有设备对象</strong>。</p>
<p><strong>设备对象的创建</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建设备对象函数原型</span></span><br><span class="line">NTSTATUS</span><br><span class="line">IoCreateDevice(</span><br><span class="line">    IN PDRIVER_OBJECT DriverObject,				<span class="comment">//负责该设备的驱动对象</span></span><br><span class="line">    IN ULONG DeviceExtensionSize,				<span class="comment">//设备对象扩展部分的大小</span></span><br><span class="line">    IN PUNICODE_STRING DeviceName OPTIONAL,		 <span class="comment">//设备名称</span></span><br><span class="line">    IN DEVICE_TYPE DeviceType,					<span class="comment">//设备类型枚举值</span></span><br><span class="line">    IN ULONG DeviceCharacteristics,				<span class="comment">//设备特征</span></span><br><span class="line">    IN BOOLEAN Exclusive,					   <span class="comment">//创建设备时是否使用互斥标志</span></span><br><span class="line">    OUT PDEVICE_OBJECT *DeviceObject			<span class="comment">//[out] 返回创建好的设备对象</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>IoCreateDevice大致流程：</p>
<ul>
<li>根据参数中指定的要求，构造出设备的名称</li>
<li>创建一个安全描述符，用于对该设备的访问控制</li>
<li>调用ObCreateObject 函数创建一个loDeviceObjectType类型的内核对象</li>
<li>如果由于自动产生的名称发生冲突而导致ObCreateObject 调用不成功，则重试此过程。</li>
<li>loCreateDevice函数初始化新建的设备对象中的成员，并调用ObInsertObject函数，将设备对象插入到进程的句柄表</li>
<li>设定该设备对象中的驱动程序对象，并将设备对象插入到驱动程序对象的设备链表</li>
</ul>
<p>设备对象的<code>DriverObject</code>字段指向负责该设备的驱动对象，<code>NextDevice</code>字段指向同属一个驱动程序的设备对象单链表。设备对象的<code>AttachedDevice</code>字段和扩展部分的<code>AttachedTo</code>字段构成了双链表节点的前后向指针。</p>
<p>在windows的层次驱动程序模型中，IO请求一般是传递给一个设备栈处理。当IO管理器接收到针对特定设备的IO请求时，I/O管理器会依次传递给设备栈中互相链接起来的设备，创建设备栈中设备的驱动对象（设备对象的<code>DriverObject</code>字段指向的驱动）相互协作处理特定设备的IO请求。</p>
<p><img src="../images/Snipaste_2018-12-03_22-47-45.png" alt="Snipaste_2018-12-03_22-47-45"></p>
<h3 id="2-3-文件对象"><a href="#2-3-文件对象" class="headerlink" title="2.3 文件对象"></a>2.3 文件对象</h3><p>驱动程序对象和设备对象都是内核对象，IO请求是针对设备对象而言的。这样带来一个问题：应用程序如何访问IO对象。</p>
<h3 id="2-4-对象声明周期管理"><a href="#2-4-对象声明周期管理" class="headerlink" title="2.4 对象声明周期管理"></a>2.4 对象声明周期管理</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/uncategorized/vmattack/2019-01-06.html" rel="next" title="vmattack">
                <i class="fa fa-chevron-left"></i> vmattack
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/uncategorized/VMAttacks论文/2019-01-10.html" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://www.plaype.me/uploads/avatar.jpg" alt="Lnju">
            
              <p class="site-author-name" itemprop="name">Lnju</p>
              <p class="site-description motion-element" itemprop="description">windows系统安全</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#IO系统"><span class="nav-number">1.</span> <span class="nav-text">IO系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、IO概述"><span class="nav-number">1.1.</span> <span class="nav-text">一、IO概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-现代计算机系统的I-O"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 1 现代计算机系统的I/O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-I-O软件技术"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 I/O软件技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-windows-IO系统结构"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 windows IO系统结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、I-O管理器"><span class="nav-number">1.2.</span> <span class="nav-text">二、I/O管理器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1驱动程序初始化"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1驱动程序初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SERVICE-BOOT-START-类型"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">SERVICE_BOOT_START 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SERVICE-SYSTEM-START类型"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">SERVICE_SYSTEM_START类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SERVICE-AUTO-START类型"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">SERVICE_AUTO_START类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SERVICE-DEMAND-START类型"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">SERVICE_DEMAND_START类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-驱动程序对象和设备对象（review过）"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 驱动程序对象和设备对象（review过）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-文件对象"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3 文件对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-对象声明周期管理"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4 对象声明周期管理</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lnju</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
